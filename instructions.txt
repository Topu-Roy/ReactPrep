# React Interview Questions App - Technical Architecture (Next.js 16)

## Table of Contents
1. [Architecture Overview](#architecture-overview)
2. [Next.js 16 Project Structure](#nextjs-16-project-structure)
3. [Data Layer Architecture](#data-layer-architecture)
4. [Server & Client Components Strategy](#server--client-components-strategy)
5. [State Management](#state-management)
6. [Search & Indexing](#search--indexing)
7. [Core Features Implementation](#core-features-implementation)
8. [Performance Optimization](#performance-optimization)
9. [Type Safety & Validation](#type-safety--validation)
10. [Testing Strategy](#testing-strategy)
11. [Development Workflow](#development-workflow)
12. [Build & Deployment](#build--deployment)

---

## Architecture Overview

### Core Technology Stack

**Framework & Runtime**
- Next.js 16 (App Router, React Server Components)
- React 19 (Server Components, Actions, use hook)
- TypeScript 5.6+ (strict mode)
- Node.js 20+ LTS

**State Management**
- Zustand 5.0+ (client state, URL state persistence)
- TanStack Query v5 (server state caching, mutations)
- React Server Components (server state)
- nuqs (type-safe URL state management)

**Data & Validation**
- Zod (runtime validation, type inference)
- Drizzle ORM (type-safe SQL queries)
- Better-SQLite3 / Turso (local-first database)
- Superjson (Date/Map/Set serialization)

**Search & Indexing**
- Orama (full-text search with typo tolerance)
- Alternative: FlexSearch (lightweight, fast)

**Content Processing**
- MDX (rich markdown with components)
- Shiki (fast syntax highlighting, build-time)
- rehype-pretty-code (code blocks)
- remark-gfm (GitHub Flavored Markdown)

**UI Components**
- Radix UI (headless primitives)
- Tailwind CSS (utility-first styling)
- tailwind-merge + clsx (conditional classes)
- Framer Motion (animations, optional)

**Testing**
- Vitest (unit/integration tests, 10x faster than Jest)
- Playwright (E2E tests)
- @testing-library/react (component tests)
- MSW (API mocking)

**Developer Tools**
- Biome (linting + formatting, replaces ESLint + Prettier)
- Turbopack (Next.js 16 default, faster than webpack)
- Knip (dead code elimination)
- tsx (TypeScript execution)
- pnpm (fast, disk-efficient package manager)

---

## Next.js 16 Project Structure

```
react-interview-app/
├── src/
│   ├── app/                              # Next.js App Router
│   │   ├── (marketing)/                  # Route group: public pages
│   │   │   ├── layout.tsx
│   │   │   ├── page.tsx                  # Landing page
│   │   │   └── about/
│   │   │       └── page.tsx
│   │   │
│   │   ├── (app)/                        # Route group: main application
│   │   │   ├── layout.tsx                # App shell with nav
│   │   │   ├── loading.tsx               # Suspense fallback
│   │   │   │
│   │   │   ├── dashboard/
│   │   │   │   ├── page.tsx              # Server Component
│   │   │   │   └── _components/          # Private components
│   │   │   │       ├── stats-card.tsx
│   │   │   │       └── recent-activity.tsx
│   │   │   │
│   │   │   ├── questions/
│   │   │   │   ├── page.tsx              # List view (Server Component)
│   │   │   │   ├── loading.tsx
│   │   │   │   ├── [slug]/
│   │   │   │   │   ├── page.tsx          # Detail view (Server Component)
│   │   │   │   │   ├── loading.tsx
│   │   │   │   │   ├── error.tsx
│   │   │   │   │   └── not-found.tsx
│   │   │   │   └── _components/
│   │   │   │       ├── question-card.tsx
│   │   │   │       ├── question-filters.tsx  # Client Component
│   │   │   │       └── answer-section.tsx    # Client Component
│   │   │   │
│   │   │   ├── study/
│   │   │   │   ├── layout.tsx            # Study mode layout
│   │   │   │   ├── page.tsx              # Mode selector
│   │   │   │   ├── flashcards/
│   │   │   │   │   └── page.tsx          # Client Component
│   │   │   │   ├── quiz/
│   │   │   │   │   ├── page.tsx
│   │   │   │   │   └── [sessionId]/
│   │   │   │   │       └── page.tsx      # Quiz session
│   │   │   │   └── review/
│   │   │   │       └── page.tsx          # Spaced repetition
│   │   │   │
│   │   │   ├── progress/
│   │   │   │   ├── page.tsx              # Dashboard (Server Component)
│   │   │   │   └── _components/
│   │   │   │       ├── progress-chart.tsx    # Client Component
│   │   │   │       └── streak-calendar.tsx   # Client Component
│   │   │   │
│   │   │   ├── bookmarks/
│   │   │   │   ├── page.tsx
│   │   │   │   └── [collectionId]/
│   │   │   │       └── page.tsx          # Collection view
│   │   │   │
│   │   │   └── search/
│   │   │       ├── page.tsx              # Server Component
│   │   │       └── _components/
│   │   │           └── search-results.tsx
│   │   │
│   │   ├── api/                          # API Routes (minimal usage)
│   │   │   ├── search/
│   │   │   │   └── route.ts              # Edge runtime search
│   │   │   └── og/
│   │   │       └── route.tsx             # Open Graph images
│   │   │
│   │   ├── layout.tsx                    # Root layout
│   │   ├── global-error.tsx              # Global error handler
│   │   ├── error.tsx                     # Error boundary
│   │   ├── not-found.tsx                 # 404 page
│   │   └── providers.tsx                 # Client providers wrapper
│   │
│   ├── components/
│   │   ├── ui/                           # Shadcn-style base components
│   │   │   ├── button.tsx
│   │   │   ├── card.tsx
│   │   │   ├── dialog.tsx
│   │   │   ├── dropdown-menu.tsx
│   │   │   ├── tabs.tsx
│   │   │   ├── badge.tsx
│   │   │   ├── skeleton.tsx
│   │   │   └── tooltip.tsx
│   │   │
│   │   ├── questions/
│   │   │   ├── question-card.tsx         # Server Component
│   │   │   ├── question-list.tsx         # Server Component
│   │   │   ├── question-detail.tsx       # Hybrid (Server wrapper)
│   │   │   ├── answer-reveal.tsx         # Client Component
│   │   │   ├── code-block.tsx            # Server Component (Shiki)
│   │   │   ├── related-questions.tsx     # Server Component
│   │   │   ├── bookmark-button.tsx       # Client Component
│   │   │   └── progress-indicator.tsx    # Client Component
│   │   │
│   │   ├── search/
│   │   │   ├── search-bar.tsx            # Client Component
│   │   │   ├── search-results.tsx        # Server Component
│   │   │   ├── search-filters.tsx        # Client Component
│   │   │   └── search-highlight.tsx      # Utility component
│   │   │
│   │   ├── study/
│   │   │   ├── flashcard.tsx             # Client Component
│   │   │   ├── quiz-question.tsx         # Client Component
│   │   │   ├── review-queue.tsx          # Hybrid
│   │   │   └── confidence-rating.tsx     # Client Component
│   │   │
│   │   ├── progress/
│   │   │   ├── progress-card.tsx         # Server Component
│   │   │   ├── category-chart.tsx        # Client Component
│   │   │   ├── streak-display.tsx        # Server Component
│   │   │   └── heatmap-calendar.tsx      # Client Component
│   │   │
│   │   └── layout/
│   │       ├── nav-bar.tsx               # Client Component
│   │       ├── sidebar.tsx               # Client Component
│   │       ├── breadcrumbs.tsx           # Server Component
│   │       ├── theme-toggle.tsx          # Client Component
│   │       └── command-menu.tsx          # Client Component
│   │
│   ├── server/                           # Server-only code
│   │   ├── actions/                      # Server Actions
│   │   │   ├── progress.ts
│   │   │   ├── bookmarks.ts
│   │   │   ├── study-session.ts
│   │   │   └── analytics.ts
│   │   │
│   │   ├── queries/                      # Data fetching functions
│   │   │   ├── questions.ts
│   │   │   ├── progress.ts
│   │   │   ├── bookmarks.ts
│   │   │   └── analytics.ts
│   │   │
│   │   ├── db/                           # Database layer
│   │   │   ├── index.ts                  # DB client
│   │   │   ├── schema.ts                 # Drizzle schema
│   │   │   └── migrations/               # SQL migrations
│   │   │
│   │   └── search/
│   │       ├── engine.ts                 # Search engine setup
│   │       ├── indexer.ts                # Index builder
│   │       └── query.ts                  # Search functions
│   │
│   ├── lib/
│   │   ├── utils/
│   │   │   ├── cn.ts                     # Class name merger
│   │   │   ├── date.ts                   # Date formatting
│   │   │   ├── format.ts                 # Text formatters
│   │   │   └── spaced-repetition.ts      # SR algorithm
│   │   │
│   │   ├── validations/                  # Zod schemas
│   │   │   ├── question.ts
│   │   │   ├── progress.ts
│   │   │   ├── bookmark.ts
│   │   │   └── study-session.ts
│   │   │
│   │   ├── stores/                       # Zustand stores
│   │   │   ├── filter-store.ts           # URL-synced filters
│   │   │   ├── ui-store.ts               # UI state
│   │   │   └── study-store.ts            # Study session state
│   │   │
│   │   └── constants/
│   │       ├── categories.ts
│   │       ├── difficulties.ts
│   │       └── keyboard-shortcuts.ts
│   │
│   ├── content/                          # Question content
│   │   ├── questions/
│   │   │   ├── hooks.ts
│   │   │   ├── state-management.ts
│   │   │   ├── performance.ts
│   │   │   ├── lifecycle.ts
│   │   │   ├── patterns.ts
│   │   │   ├── context-api.ts
│   │   │   ├── routing.ts
│   │   │   ├── forms.ts
│   │   │   ├── testing.ts
│   │   │   └── advanced.ts
│   │   ├── index.ts                      # Aggregates all questions
│   │   └── validate.ts                   # Build-time validation
│   │
│   ├── hooks/                            # Custom React hooks
│   │   ├── use-local-storage.ts
│   │   ├── use-debounce.ts
│   │   ├── use-media-query.ts
│   │   ├── use-intersection-observer.ts
│   │   ├── use-keyboard-shortcut.ts
│   │   └── use-mounted.ts
│   │
│   └── types/                            # Global TypeScript types
│       ├── index.ts
│       └── database.ts
│
├── scripts/                              # Build & dev scripts
│   ├── validate-questions.ts             # Validate question data
│   ├── build-search-index.ts             # Pre-build search index
│   ├── add-question.ts                   # CLI for adding questions
│   ├── db-migrate.ts                     # Run migrations
│   ├── db-seed.ts                        # Seed database
│   └── check-duplicates.ts               # Find duplicate questions
│
├── tests/
│   ├── setup.ts                          # Test setup
│   ├── unit/
│   │   ├── utils/
│   │   ├── hooks/
│   │   └── lib/
│   ├── integration/
│   │   ├── questions/
│   │   ├── progress/
│   │   └── study/
│   └── e2e/
│       ├── questions.spec.ts
│       ├── study-flow.spec.ts
│       └── progress.spec.ts
│
├── public/
│   ├── fonts/
│   └── images/
│
├── drizzle/                              # Drizzle migrations
│   └── migrations/
│
├── .github/
│   └── workflows/
│       ├── ci.yml
│       ├── deploy.yml
│       └── validate-questions.yml
│
├── biome.json                            # Biome config
├── next.config.ts                        # Next.js config
├── tailwind.config.ts                    # Tailwind config
├── tsconfig.json                         # TypeScript config
├── drizzle.config.ts                     # Drizzle ORM config
├── vitest.config.ts                      # Vitest config
├── playwright.config.ts                  # Playwright config
├── .env.example                          # Environment variables
├── package.json
└── pnpm-lock.yaml
```

---

## Data Layer Architecture

### Schema Definitions (Zod + TypeScript)

```typescript
// src/lib/validations/question.ts
import { z } from 'zod';

// Enums as const arrays for better type inference
export const CATEGORIES = [
  'hooks',
  'state-management',
  'performance',
  'lifecycle',
  'patterns',
  'context-api',
  'routing',
  'forms',
  'testing',
  'advanced',
] as const;

export const DIFFICULTIES = ['beginner', 'intermediate', 'advanced'] as const;

export const PROGRESS_STATUSES = [
  'not-started',
  'learning',
  'confident',
  'mastered',
] as const;

// Zod schemas
export const CategorySchema = z.enum(CATEGORIES);
export const DifficultySchema = z.enum(DIFFICULTIES);
export const ProgressStatusSchema = z.enum(PROGRESS_STATUSES);

export const ResourceSchema = z.object({
  title: z.string(),
  url: z.string().url(),
  type: z.enum(['docs', 'article', 'video', 'github', 'course']).optional(),
});

export const QuestionSchema = z.object({
  id: z.string().min(1),
  slug: z.string().min(1).regex(/^[a-z0-9-]+$/),
  category: CategorySchema,
  difficulty: DifficultySchema,
  title: z.string().min(5).max(200),
  question: z.string().min(10),
  answer: z.string().min(10),
  codeExample: z.string().optional(),
  hints: z.array(z.string()).optional(),
  tags: z.array(z.string()).min(1),
  relatedQuestions: z.array(z.string()).default([]),
  resources: z.array(ResourceSchema).default([]),
  metadata: z.object({
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date(),
    estimatedReadTime: z.number().positive().optional(),
    popularity: z.number().default(0),
  }),
});

export const ProgressSchema = z.object({
  id: z.string(),
  userId: z.string().optional(),
  questionId: z.string(),
  status: ProgressStatusSchema,
  confidenceLevel: z.number().int().min(1).max(5),
  reviewCount: z.number().int().default(0),
  lastReviewedAt: z.coerce.date().optional(),
  nextReviewAt: z.coerce.date().optional(),
  timeSpentSeconds: z.number().int().default(0),
  notes: z.string().max(1000).optional(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export const BookmarkSchema = z.object({
  id: z.string(),
  userId: z.string().optional(),
  questionId: z.string(),
  collectionId: z.string().optional(),
  tags: z.array(z.string()).default([]),
  notes: z.string().max(500).optional(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export const StudySessionSchema = z.object({
  id: z.string(),
  userId: z.string().optional(),
  mode: z.enum(['flashcards', 'quiz', 'review', 'random']),
  questionIds: z.array(z.string()),
  startedAt: z.coerce.date(),
  completedAt: z.coerce.date().optional(),
  totalQuestions: z.number().int(),
  completedQuestions: z.number().int().default(0),
  correctAnswers: z.number().int().default(0),
  averageConfidence: z.number().optional(),
});

// Type inference
export type Question = z.infer<typeof QuestionSchema>;
export type Category = z.infer<typeof CategorySchema>;
export type Difficulty = z.infer<typeof DifficultySchema>;
export type ProgressStatus = z.infer<typeof ProgressStatusSchema>;
export type Progress = z.infer<typeof ProgressSchema>;
export type Bookmark = z.infer<typeof BookmarkSchema>;
export type StudySession = z.infer<typeof StudySessionSchema>;
export type Resource = z.infer<typeof ResourceSchema>;
```

### Database Schema (Drizzle ORM)

```typescript
// src/server/db/schema.ts
import { sqliteTable, text, integer, real } from 'drizzle-orm/sqlite-core';
import { sql } from 'drizzle-orm';

export const questions = sqliteTable('questions', {
  id: text('id').primaryKey(),
  slug: text('slug').notNull().unique(),
  category: text('category').notNull(),
  difficulty: text('difficulty').notNull(),
  title: text('title').notNull(),
  question: text('question').notNull(),
  answer: text('answer').notNull(),
  codeExample: text('code_example'),
  hints: text('hints'), // JSON array
  tags: text('tags').notNull(), // JSON array
  relatedQuestions: text('related_questions'), // JSON array
  resources: text('resources'), // JSON array
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
  estimatedReadTime: integer('estimated_read_time'),
  popularity: integer('popularity').default(0),
});

export const progress = sqliteTable('progress', {
  id: text('id').primaryKey(),
  userId: text('user_id'),
  questionId: text('question_id').notNull().references(() => questions.id),
  status: text('status').notNull(),
  confidenceLevel: integer('confidence_level').notNull(),
  reviewCount: integer('review_count').default(0),
  lastReviewedAt: integer('last_reviewed_at', { mode: 'timestamp' }),
  nextReviewAt: integer('next_review_at', { mode: 'timestamp' }),
  timeSpentSeconds: integer('time_spent_seconds').default(0),
  notes: text('notes'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
});

export const bookmarks = sqliteTable('bookmarks', {
  id: text('id').primaryKey(),
  userId: text('user_id'),
  questionId: text('question_id').notNull().references(() => questions.id),
  collectionId: text('collection_id'),
  tags: text('tags'), // JSON array
  notes: text('notes'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
});

export const studySessions = sqliteTable('study_sessions', {
  id: text('id').primaryKey(),
  userId: text('user_id'),
  mode: text('mode').notNull(),
  questionIds: text('question_ids').notNull(), // JSON array
  startedAt: integer('started_at', { mode: 'timestamp' }).notNull(),
  completedAt: integer('completed_at', { mode: 'timestamp' }),
  totalQuestions: integer('total_questions').notNull(),
  completedQuestions: integer('completed_questions').default(0),
  correctAnswers: integer('correct_answers').default(0),
  averageConfidence: real('average_confidence'),
});

export const collections = sqliteTable('collections', {
  id: text('id').primaryKey(),
  userId: text('user_id'),
  name: text('name').notNull(),
  description: text('description'),
  isPublic: integer('is_public', { mode: 'boolean' }).default(false),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
});

// Indexes for performance
export const questionsCategoryIdx = sqliteTable('questions_category_idx', {
  category: text('category'),
});

export const progressUserQuestionIdx = sqliteTable('progress_user_question_idx', {
  userId: text('user_id'),
  questionId: text('question_id'),
});
```

### Data Access Layer (Server Queries)

```typescript
// src/server/queries/questions.ts
import 'server-only';
import { cache } from 'react';
import { db } from '@/server/db';
import { questions } from '@/server/db/schema';
import { eq, and, inArray, sql } from 'drizzle-orm';
import type { Question, Category, Difficulty } from '@/lib/validations/question';

// React cache ensures function runs once per request
export const getQuestions = cache(async (): Promise<Question[]> => {
  const result = await db.select().from(questions);
  
  return result.map(row => ({
    ...row,
    tags: JSON.parse(row.tags),
    relatedQuestions: row.relatedQuestions ? JSON.parse(row.relatedQuestions) : [],
    resources: row.resources ? JSON.parse(row.resources) : [],
    hints: row.hints ? JSON.parse(row.hints) : undefined,
    metadata: {
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
      estimatedReadTime: row.estimatedReadTime ?? undefined,
      popularity: row.popularity ?? 0,
    },
  }));
});

export const getQuestionBySlug = cache(async (slug: string): Promise<Question | null> => {
  const result = await db.select().from(questions).where(eq(questions.slug, slug)).limit(1);
  
  if (!result[0]) return null;
  
  const row = result[0];
  return {
    ...row,
    tags: JSON.parse(row.tags),
    relatedQuestions: row.relatedQuestions ? JSON.parse(row.relatedQuestions) : [],
    resources: row.resources ? JSON.parse(row.resources) : [],
    hints: row.hints ? JSON.parse(row.hints) : undefined,
    metadata: {
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
      estimatedReadTime: row.estimatedReadTime ?? undefined,
      popularity: row.popularity ?? 0,
    },
  };
});

export const getQuestionsByCategory = cache(async (category: Category): Promise<Question[]> => {
  const allQuestions = await getQuestions();
  return allQuestions.filter(q => q.category === category);
});

export const getQuestionsByDifficulty = cache(async (difficulty: Difficulty): Promise<Question[]> => {
  const allQuestions = await getQuestions();
  return allQuestions.filter(q => q.difficulty === difficulty);
});

export const getRelatedQuestions = cache(async (questionId: string): Promise<Question[]> => {
  const question = await getQuestions().then(qs => qs.find(q => q.id === questionId));
  if (!question || !question.relatedQuestions.length) return [];
  
  const allQuestions = await getQuestions();
  return allQuestions.filter(q => question.relatedQuestions.includes(q.id));
});

export const getQuestionsPaginated = cache(async ({
  page = 1,
  pageSize = 20,
  category,
  difficulty,
  tags,
  searchQuery,
}: {
  page?: number;
  pageSize?: number;
  category?: Category;
  difficulty?: Difficulty;
  tags?: string[];
  searchQuery?: string;
}) => {
  let filteredQuestions = await getQuestions();
  
  // Apply filters
  if (category) {
    filteredQuestions = filteredQuestions.filter(q => q.category === category);
  }
  if (difficulty) {
    filteredQuestions = filteredQuestions.filter(q => q.difficulty === difficulty);
  }
  if (tags?.length) {
    filteredQuestions = filteredQuestions.filter(q => 
      tags.some(tag => q.tags.includes(tag))
    );
  }
  if (searchQuery) {
    const query = searchQuery.toLowerCase();
    filteredQuestions = filteredQuestions.filter(q =>
      q.title.toLowerCase().includes(query) ||
      q.question.toLowerCase().includes(query) ||
      q.tags.some(tag => tag.toLowerCase().includes(query))
    );
  }
  
  const total = filteredQuestions.length;
  const totalPages = Math.ceil(total / pageSize);
  const start = (page - 1) * pageSize;
  const end = start + pageSize;
  
  return {
    questions: filteredQuestions.slice(start, end),
    pagination: {
      page,
      pageSize,
      total,
      totalPages,
      hasMore: page < totalPages,
    },
  };
});

// Get popular questions
export const getPopularQuestions = cache(async (limit: number = 10): Promise<Question[]> => {
  const allQuestions = await getQuestions();
  return allQuestions
    .sort((a, b) => (b.metadata.popularity ?? 0) - (a.metadata.popularity ?? 0))
    .slice(0, limit);
});

// Get random questions
export const getRandomQuestions = cache(async (count: number = 5): Promise<Question[]> => {
  const allQuestions = await getQuestions();
  const shuffled = [...allQuestions].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, count);
});
```

### Server Actions (Mutations)

```typescript
// src/server/actions/progress.ts
'use server';

import { revalidatePath } from 'next/cache';
import { db } from '@/server/db';
import { progress } from '@/server/db/schema';
import { eq, and } from 'drizzle-orm';
import { ProgressSchema, type ProgressStatus } from '@/lib/validations/question';
import { calculateNextReviewDate } from '@/lib/utils/spaced-repetition';

export async function updateProgress(data: {
  questionId: string;
  status: ProgressStatus;
  confidenceLevel: number;
  timeSpent?: number;
  notes?: string;
}) {
  try {
    const userId = 'anonymous'; // Replace with actual auth
    
    // Validate input
    const validated = ProgressSchema.partial().parse({
      questionId: data.questionId,
      status: data.status,
      confidenceLevel: data.confidenceLevel,
      notes: data.notes,
    });
    
    // Check if progress exists
    const existing = await db.select()
      .from(progress)
      .where(and(
        eq(progress.userId, userId),
        eq(progress.questionId, data.questionId)
      ))
      .limit(1);
    
    const now = new Date();
    const nextReview = calculateNextReviewDate(
      data.confidenceLevel,
      existing[0]?.reviewCount ?? 0
    );
    
    if (existing[0]) {
      // Update existing
      await db.update(progress)
        .set({
          status: data.status,
          confidenceLevel: data.confidenceLevel,
          reviewCount: existing[0].reviewCount + 1,
          lastReviewedAt: now,
          nextReviewAt: nextReview,
          timeSpentSeconds: existing[0].timeSpentSeconds + (data.timeSpent ?? 0),
          notes: data.notes ?? existing[0].notes,
          updatedAt: now,
        })
        .where(eq(progress.id, existing[0].id));
    } else {
      // Create new
      await db.insert(progress).values({
        id: crypto.randomUUID(),
        userId,
        questionId: data.questionId,
        status: data.status,
        confidenceLevel: data.confidenceLevel,
        reviewCount: 1,
        lastReviewedAt: now,
        nextReviewAt: nextReview,
        timeSpentSeconds: data.timeSpent ?? 0,
        notes: data.notes,
        createdAt: now,
        updatedAt: now,
      });
    }
    
    revalidatePath('/progress');
    revalidatePath(`/questions/${data.questionId}`);
    
    return { success: true };
  } catch (error) {
    console.error('Failed to update progress:', error);
    return { success: false, error: 'Failed to update progress' };
  }
}

export async function resetProgress(questionId: string) {
  try {
    const userId = 'anonymous';
    
    await db.delete(progress)
      .where(and(
        eq(progress.userId, userId),
        eq(progress.questionId, questionId)
      ));
    
    revalidatePath('/progress');
    revalidatePath(`/questions/${questionId}`);
    
    return { success: true };
  } catch (error) {
    console.error('Failed to reset progress:', error);
    return { success: false, error: 'Failed to reset progress' };
  }
}
```

---

## Server & Client Components Strategy

### Component Classification

**Server Components (Default)**
- Question lists and cards
- Question detail pages
- Progress dashboards (static parts)
- Search results display
- Related questions sections
- Code blocks with syntax highlighting
- Breadcrumbs
- Metadata displays

**Client Components (Interactive)**
- Answer reveal toggles
- Bookmark buttons
- Confidence rating inputs
- Search input with debouncing
- Filter controls
- Navigation menus
- Theme toggles
- Flashcard flip animations
- Quiz answer selection
- Progress charts (interactive)
- Modals and dialogs
- Toast notifications

**Hybrid Patterns**
```typescript
// Server Component wrapper with Client Component for interactivity
// src/components/questions/question-detail.tsx

import { getQuestionBySlug } from '@/server/queries/questions';
import { AnswerReveal } from './answer-reveal';
import { CodeBlock } from './code-block';
import { BookmarkButton } from './bookmark-button';

export async function QuestionDetail({ slug }: { slug: string }) {
  const question = await getQuestionBySlug(slug);
  
  if (!question) {
    return <div>Question not found</div>;
  }
  
  return (
    <article>
      <header>
        <h1>{question.title}</h1>
        <div>
          <span>{question.difficulty}</span>
          <span>{question.category}</span>
          <BookmarkButton questionId={question.id} /> {/* Client Component */}
        </div>
      </header>
      
      <div>
        <ReactMarkdown>{question.question}</ReactMarkdown>
      </div>
      
      {/* Client Component wraps server-rendered content */}
      <AnswerReveal>
        <div>
          <ReactMarkdown>{question.answer}</ReactMarkdown>
          {question.codeExample && (
            <CodeBlock code={question.codeExample} /> {/* Server Component */}
          )}
        </div>
      </AnswerReveal>
    </article>
  );
}
```

### Data Flow Patterns

**Server to Client Prop Passing**
```typescript
// Pass serializable data from Server to Client Components
// src/app/(app)/questions/[slug]/page.tsx

import { getQuestionBySlug } from '@/server/queries/questions';
import { QuestionInteractions } from './_components/question-interactions';

export default async function QuestionPage({ params }: { params: { slug: string } }) {
  const question = await getQuestionBySlug(params.slug);
  
  return (
    <div>
      {/* Server Component renders static content */}
      <h1>{question.title}</h1>
      
      {/* Pass minimal data to Client Component */}
      <QuestionInteractions 
        questionId={question.id}
        initialBookmarked={false} // Fetch from DB
      />
    </div>
  );
}
```

**Server Actions with Client Components**
```typescript
// src/components/questions/bookmark-button.tsx
'use client';

import { useTransition } from 'react';
import { toggleBookmark } from '@/server/actions/bookmarks';

export function BookmarkButton({ 
  questionId,
  initialBookmarked 
}: { 
  questionId: string;
  initialBookmarked: boolean;
}) {
  const [isPending, startTransition] = useTransition();
  const [isBookmarked, setIsBookmarked] = useState(initialBookmarked);
  
  const handleToggle = () => {
    startTransition(async () => {
      const result = await toggleBookmark(questionId);
      if (result.success) {
        setIsBookmarked(result.bookmarked);
      }
    });
  };
  
  return (
    <button onClick={handleToggle} disabled={isPending}>
      {isBookmarked ? 'Bookmarked' : 'Bookmark'}
    </button>
  );
}
```

---

## State Management

### Architecture Decision: Multi-Layer State

**1. Server State (React Server Components + TanStack Query)**
- Question data
- Progress data
- Bookmarks
- Analytics

**2. URL State (nuqs - Type-safe URL state)**
- Filters (category, difficulty, tags)
- Search queries
- Pagination
- Sort order

**3. Client State (Zustand)**
- UI state (modals, sidebars, themes)
- Study session state
- Temporary form state

**4. Local Storage (via hooks)**
- User preferences
- Draft notes
- Last visited pages

### Implementation Examples

#### URL State with nuqs

```typescript
// src/lib/stores/filter-store.ts
import { parseAsStringEnum, parseAsArrayOf, parseAsString, useQueryStates } from 'nuqs';
import { CATEGORIES, DIFFICULTIES } from '@/lib/validations/question';

const searchParamsParser = {
  category: parseAsStringEnum(CATEGORIES),
  difficulty: parseAsStringEnum(DIFFICULTIES),
  tags: parseAsArrayOf(parseAsString),
  search: parseAsString,
  page: parseAsInteger.withDefault(1),
};

export function useQuestionFilters() {
  const [filters, setFilters] = useQueryStates(searchParamsParser, {
    history: 'push', // or 'replace'
    shallow: false,  // trigger full navigation
  });
  
  const resetFilters = () => {
    setFilters({
      category: null,
      difficulty: null,
      tags: null,
      search: null,
      page: 1,
    });
  };
  
  return { filters, setFilters, resetFilters };
}
```

#### Client State with Zustand

```typescript
// src/lib/stores/ui-store.ts
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

interface UIState {
  sidebarOpen: boolean;
  theme: 'light' | 'dark' | 'system';
  codeTheme: string;
  commandMenuOpen: boolean;
  
  toggleSidebar: () => void;
  setTheme: (theme: UIState['theme']) => void;
  setCodeTheme: (theme: string) => void;
  toggleCommandMenu: () => void;
}

export const useUIStore = create<UIState>()(
  persist(
    (set) => ({
      sidebarOpen: true,
      theme: 'system',
      codeTheme: 'github-dark',
      commandMenuOpen: false,
      
      toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
      setTheme: (theme) => set({ theme }),
      setCodeTheme: (codeTheme) => set({ codeTheme }),
      toggleCommandMenu: () => set((state) => ({ commandMenuOpen: !state.commandMenuOpen })),
    }),
    {
      name: 'ui-storage',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({ 
        theme: state.theme,
        codeTheme: state.codeTheme 
      }),
    }
  )
);
```

#### Study Session State

```typescript
// src/lib/stores/study-store.ts
import { create } from 'zustand';
import type { Question } from '@/lib/validations/question';

interface StudyState {
  mode: 'flashcards' | 'quiz' | 'review' | null;
  questions: Question[];
  currentIndex: number;
  answers: Map<string, boolean>;
  startTime: Date | null;
  
  startSession: (mode: StudyState['mode'], questions: Question[]) => void;
  nextQuestion: () => void;
  previousQuestion: () => void;
  recordAnswer: (questionId: string, correct: boolean) => void;
  endSession: () => void;
  reset: () => void;
}

export const useStudyStore = create<StudyState>((set) => ({
  mode: null,
  questions: [],
  currentIndex: 0,
  answers: new Map(),
  startTime: null,
  
  startSession: (mode, questions) => set({
    mode,
    questions,
    currentIndex: 0,
    answers: new Map(),
    startTime: new Date(),
  }),
  
  nextQuestion: () => set((state) => ({
    currentIndex: Math.min(state.currentIndex + 1, state.questions.length - 1),
  })),
  
  previousQuestion: () => set((state) => ({
    currentIndex: Math.max(state.currentIndex - 1, 0),
  })),
  
  recordAnswer: (questionId, correct) => set((state) => {
    const newAnswers = new Map(state.answers);
    newAnswers.set(questionId, correct);
    return { answers: newAnswers };
  }),
  
  endSession: () => set({
    mode: null,
    currentIndex: 0,
    startTime: null,
  }),
  
  reset: () => set({
    mode: null,
    questions: [],
    currentIndex: 0,
    answers: new Map(),
    startTime: null,
  }),
}));
```

---

## Search & Indexing

### Search Engine: Orama

```typescript
// src/server/search/engine.ts
import { create, insertMultiple, search as oramaSearch } from '@orama/orama';
import { getQuestions } from '@/server/queries/questions';
import type { Question } from '@/lib/validations/question';

let searchIndex: Awaited<ReturnType<typeof create>> | null = null;

export async function initializeSearchIndex() {
  if (searchIndex) return searchIndex;
  
  searchIndex = await create({
    schema: {
      id: 'string',
      slug: 'string',
      title: 'string',
      question: 'string',
      answer: 'string',
      category: 'string',
      difficulty: 'string',
      tags: 'string[]',
    },
  });
  
  const questions = await getQuestions();
  
  await insertMultiple(searchIndex, questions.map(q => ({
    id: q.id,
    slug: q.slug,
    title: q.title,
    question: q.question,
    answer: q.answer,
    category: q.category,
    difficulty: q.difficulty,
    tags: q.tags,
  })));
  
  return searchIndex;
}

export async function searchQuestions(query: string, options?: {
  category?: string;
  difficulty?: string;
  limit?: number;
}) {
  const index = await initializeSearchIndex();
  
  const results = await oramaSearch(index, {
    term: query,
    properties: ['title', 'question', 'tags'],
    limit: options?.limit ?? 20,
    threshold: 0.6, // Typo tolerance
  });
  
  let hits = results.hits;
  
  // Apply filters
  if (options?.category) {
    hits = hits.filter(hit => hit.document.category === options.category);
  }
  if (options?.difficulty) {
    hits = hits.filter(hit => hit.document.difficulty === options.difficulty);
  }
  
  return {
    results: hits.map(hit => hit.document),
    count: hits.length,
    elapsed: results.elapsed,
  };
}
```

### Search API Route (Edge Runtime)

```typescript
// src/app/api/search/route.ts
import { searchQuestions } from '@/server/search/engine';
import { NextRequest, NextResponse } from 'next/server';

export const runtime = 'edge';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const query = searchParams.get('q');
  const category = searchParams.get('category') || undefined;
  const difficulty = searchParams.get('difficulty') || undefined;
  const limit = parseInt(searchParams.get('limit') || '20');
  
  if (!query) {
    return NextResponse.json({ error: 'Query parameter required' }, { status: 400 });
  }
  
  try {
    const results = await searchQuestions(query, {
      category,
      difficulty,
      limit,
    });
    
    return NextResponse.json(results);
  } catch (error) {
    console.error('Search error:', error);
    return NextResponse.json({ error: 'Search failed' }, { status: 500 });
  }
}
```

### Client-Side Search Component

```typescript
// src/components/search/search-bar.tsx
'use client';

import { useState } from 'react';
import { useDebounce } from '@/hooks/use-debounce';
import { useQuery } from '@tanstack/react-query';

export function SearchBar() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 300);
  
  const { data, isLoading } = useQuery({
    queryKey: ['search', debouncedQuery],
    queryFn: async () => {
      if (!debouncedQuery) return null;
      
      const response = await fetch(`/api/search?q=${encodeURIComponent(debouncedQuery)}`);
      if (!response.ok) throw new Error('Search failed');
      
      return response.json();
    },
    enabled: debouncedQuery.length > 2,
    staleTime: 5 * 60 * 1000, // Cache for 5 minutes
  });
  
  return (
    <div>
      <input
        type="search"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search questions..."
      />
      
      {isLoading && <div>Searching...</div>}
      
      {data?.results && (
        <div>
          {data.results.map((result) => (
            <SearchResultItem key={result.id} result={result} />
          ))}
        </div>
      )}
    </div>
  );
}
```

---

## Core Features Implementation

### 1. Question Browsing

**List Page (Server Component)**
```typescript
// src/app/(app)/questions/page.tsx
import { Suspense } from 'react';
import { getQuestionsPaginated } from '@/server/queries/questions';
import { QuestionList } from '@/components/questions/question-list';
import { QuestionFilters } from '@/components/questions/question-filters';
import { QuestionListSkeleton } from '@/components/questions/question-list-skeleton';

export default async function QuestionsPage({
  searchParams,
}: {
  searchParams: {
    category?: string;
    difficulty?: string;
    page?: string;
    tags?: string;
  };
}) {
  const page = parseInt(searchParams.page || '1');
  const category = searchParams.category as any;
  const difficulty = searchParams.difficulty as any;
  const tags = searchParams.tags?.split(',');
  
  const { questions, pagination } = await getQuestionsPaginated({
    page,
    pageSize: 20,
    category,
    difficulty,
    tags,
  });
  
  return (
    <div>
      <h1>React Interview Questions</h1>
      
      <Suspense fallback={<div>Loading filters...</div>}>
        <QuestionFilters />
      </Suspense>
      
      <Suspense fallback={<QuestionListSkeleton />}>
        <QuestionList 
          questions={questions} 
          pagination={pagination}
        />
      </Suspense>
    </div>
  );
}
```

**Detail Page (Server Component with Client Interactions)**
```typescript
// src/app/(app)/questions/[slug]/page.tsx
import { notFound } from 'next/navigation';
import { getQuestionBySlug, getRelatedQuestions } from '@/server/queries/questions';
import { AnswerReveal } from '@/components/questions/answer-reveal';
import { BookmarkButton } from '@/components/questions/bookmark-button';
import { ProgressTracker } from '@/components/questions/progress-tracker';
import { CodeBlock } from '@/components/questions/code-block';
import { RelatedQuestions } from '@/components/questions/related-questions';
import ReactMarkdown from 'react-markdown';

export async function generateMetadata({ params }: { params: { slug: string } }) {
  const question = await getQuestionBySlug(params.slug);
  
  if (!question) {
    return { title: 'Question Not Found' };
  }
  
  return {
    title: `${question.title} | React Interview Questions`,
    description: question.question.slice(0, 160),
  };
}

export default async function QuestionDetailPage({ params }: { params: { slug: string } }) {
  const question = await getQuestionBySlug(params.slug);
  
  if (!question) {
    notFound();
  }
  
  const relatedQuestions = await getRelatedQuestions(question.id);
  
  return (
    <article>
      <header>
        <div>
          <span>{question.category}</span>
          <span>{question.difficulty}</span>
        </div>
        <h1>{question.title}</h1>
        <div>
          <BookmarkButton questionId={question.id} />
          <ProgressTracker questionId={question.id} />
        </div>
      </header>
      
      <section>
        <h2>Question</h2>
        <ReactMarkdown>{question.question}</ReactMarkdown>
      </section>
      
      <AnswerReveal questionId={question.id}>
        <section>
          <h2>Answer</h2>
          <ReactMarkdown>{question.answer}</ReactMarkdown>
          
          {question.codeExample && (
            <CodeBlock 
              code={question.codeExample}
              language="tsx"
            />
          )}
        </section>
      </AnswerReveal>
      
      {question.resources.length > 0 && (
        <section>
          <h3>Resources</h3>
          <ul>
            {question.resources.map((resource, idx) => (
              <li key={idx}>
                <a href={resource.url} target="_blank" rel="noopener noreferrer">
                  {resource.title}
                </a>
              </li>
            ))}
          </ul>
        </section>
      )}
      
      {relatedQuestions.length > 0 && (
        <RelatedQuestions questions={relatedQuestions} />
      )}
      
      <div>
        {question.tags.map(tag => (
          <span key={tag}>{tag}</span>
        ))}
      </div>
    </article>
  );
}
```

### 2. Progress Tracking

**Progress Dashboard (Server Component)**
```typescript
// src/app/(app)/progress/page.tsx
import { getProgressStats, getRecentActivity } from '@/server/queries/progress';
import { ProgressChart } from '@/components/progress/progress-chart';
import { StreakCalendar } from '@/components/progress/streak-calendar';
import { CategoryProgress } from '@/components/progress/category-progress';

export default async function ProgressPage() {
  const stats = await getProgressStats();
  const recentActivity = await getRecentActivity(7); // Last 7 days
  
  return (
    <div>
      <h1>Your Progress</h1>
      
      <div className="grid">
        <div>
          <h3>Total Questions</h3>
          <p>{stats.totalCompleted} / {stats.totalQuestions}</p>
        </div>
        
        <div>
          <h3>Mastered</h3>
          <p>{stats.masteredCount}</p>
        </div>
        
        <div>
          <h3>Current Streak</h3>
          <p>{stats.currentStreak} days</p>
        </div>
        
        <div>
          <h3>Total Study Time</h3>
          <p>{Math.floor(stats.totalTimeSeconds / 60)} minutes</p>
        </div>
      </div>
      
      <ProgressChart data={recentActivity} />
      
      <CategoryProgress stats={stats.byCategory} />
      
      <StreakCalendar activity={stats.activityMap} />
    </div>
  );
}
```

**Progress Tracker Component (Client)**
```typescript
// src/components/questions/progress-tracker.tsx
'use client';

import { useState, useTransition } from 'react';
import { updateProgress } from '@/server/actions/progress';
import { PROGRESS_STATUSES } from '@/lib/validations/question';
import type { ProgressStatus } from '@/lib/validations/question';

export function ProgressTracker({ 
  questionId,
  initialStatus = 'not-started'
}: { 
  questionId: string;
  initialStatus?: ProgressStatus;
}) {
  const [status, setStatus] = useState<ProgressStatus>(initialStatus);
  const [confidence, setConfidence] = useState(3);
  const [isPending, startTransition] = useTransition();
  
  const handleUpdate = () => {
    startTransition(async () => {
      const result = await updateProgress({
        questionId,
        status,
        confidenceLevel: confidence,
      });
      
      if (result.success) {
        // Show success toast
      }
    });
  };
  
  return (
    <div>
      <div>
        <label>Status</label>
        <select value={status} onChange={(e) => setStatus(e.target.value as ProgressStatus)}>
          {PROGRESS_STATUSES.map(s => (
            <option key={s} value={s}>{s}</option>
          ))}
        </select>
      </div>
      
      <div>
        <label>Confidence (1-5)</label>
        <input
          type="range"
          min="1"
          max="5"
          value={confidence}
          onChange={(e) => setConfidence(parseInt(e.target.value))}
        />
        <span>{confidence}</span>
      </div>
      
      <button onClick={handleUpdate} disabled={isPending}>
        {isPending ? 'Updating...' : 'Update Progress'}
      </button>
    </div>
  );
}
```

### 3. Study Modes

**Flashcard Mode (Client Component)**
```typescript
// src/app/(app)/study/flashcards/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { useStudyStore } from '@/lib/stores/study-store';
import { FlashCard } from '@/components/study/flashcard';

export default function FlashcardsPage() {
  const { questions, currentIndex, nextQuestion, previousQuestion } = useStudyStore();
  const [isFlipped, setIsFlipped] = useState(false);
  
  const currentQuestion = questions[currentIndex];
  
  if (!currentQuestion) {
    return <div>No questions selected for study</div>;
  }
  
  const handleNext = () => {
    setIsFlipped(false);
    nextQuestion();
  };
  
  const handlePrevious = () => {
    setIsFlipped(false);
    previousQuestion();
  };
  
  return (
    <div>
      <div>
        Question {currentIndex + 1} of {questions.length}
      </div>
      
      <FlashCard
        question={currentQuestion}
        isFlipped={isFlipped}
        onFlip={() => setIsFlipped(!isFlipped)}
      />
      
      <div>
        <button onClick={handlePrevious} disabled={currentIndex === 0}>
          Previous
        </button>
        <button onClick={handleNext} disabled={currentIndex === questions.length - 1}>
          Next
        </button>
      </div>
    </div>
  );
}
```

**Spaced Repetition Algorithm**
```typescript
// src/lib/utils/spaced-repetition.ts

/**
 * Calculate next review date using SM-2 algorithm variant
 * @param confidence - User's confidence level (1-5)
 * @param reviewCount - Number of times reviewed
 * @returns Next review date
 */
export function calculateNextReviewDate(
  confidence: number,
  reviewCount: number
): Date {
  const now = new Date();
  
  // Base intervals in days
  const intervals = [
    1,    // First review: 1 day
    3,    // Second review: 3 days
    7,    // Third review: 1 week
    14,   // Fourth review: 2 weeks
    30,   // Fifth review: 1 month
    60,   // Sixth review: 2 months
  ];
  
  // Get base interval
  let interval = intervals[Math.min(reviewCount, intervals.length - 1)];
  
  // Modify based on confidence (1-5)
  const confidenceMultiplier = {
    1: 0.5,   // Very uncertain: review sooner
    2: 0.75,  // Uncertain: review a bit sooner
    3: 1.0,   // Neutral: use base interval
    4: 1.5,   // Confident: review later
    5: 2.0,   // Very confident: review much later
  };
  
  interval *= confidenceMultiplier[confidence as keyof typeof confidenceMultiplier] || 1.0;
  
  // Add interval to current date
  const nextDate = new Date(now);
  nextDate.setDate(nextDate.getDate() + Math.round(interval));
  
  return nextDate;
}

/**
 * Get questions due for review
 */
export function isDueForReview(nextReviewAt: Date | null): boolean {
  if (!nextReviewAt) return true;
  return new Date() >= new Date(nextReviewAt);
}
```

---

## Performance Optimization

### Next.js Configuration

```typescript
// next.config.ts
import type { NextConfig } from 'next';

const config: NextConfig = {
  reactStrictMode: true,
  
  // Turbopack (default in Next.js 16)
  experimental: {
    turbo: {
      rules: {
        '*.svg': {
          loaders: ['@svgr/webpack'],
          as: '*.js',
        },
      },
    },
  },
  
  // Compiler options
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production' ? {
      exclude: ['error', 'warn'],
    } : false,
  },
  
  // Image optimization
  images: {
    formats: ['image/avif', 'image/webp'],
    deviceSizes: [640, 750, 828, 1080, 1200],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
  
  // Headers for caching
  async headers() {
    return [
      {
        source: '/fonts/:path*',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ];
  },
};

export default config;
```

### Code Splitting Strategy

```typescript
// Dynamic imports for heavy components
import dynamic from 'next/dynamic';

// Load chart library only when needed
const ProgressChart = dynamic(
  () => import('@/components/progress/progress-chart'),
  { 
    loading: () => <ChartSkeleton />,
    ssr: false, // Don't render on server if not needed
  }
);

// Lazy load quiz component
const QuizMode = dynamic(
  () => import('@/components/study/quiz-mode'),
  { loading: () => <div>Loading quiz...</div> }
);
```

### React Suspense Boundaries

```typescript
// src/app/(app)/questions/page.tsx
import { Suspense } from 'react';

export default function QuestionsPage() {
  return (
    <div>
      <Suspense fallback={<QuestionListSkeleton />}>
        <QuestionList />
      </Suspense>
      
      <Suspense fallback={<div>Loading filters...</div>}>
        <QuestionFilters />
      </Suspense>
    </div>
  );
}
```

### Parallel Data Fetching

```typescript
// Fetch multiple resources in parallel
export default async function DashboardPage() {
  const [stats, recentActivity, popularQuestions] = await Promise.all([
    getProgressStats(),
    getRecentActivity(7),
    getPopularQuestions(5),
  ]);
  
  return <Dashboard stats={stats} activity={recentActivity} popular={popularQuestions} />;
}
```

### Streaming with Suspense

```typescript
// src/app/(app)/dashboard/page.tsx
import { Suspense } from 'react';

async function Stats() {
  const stats = await getProgressStats(); // Slow query
  return <StatsCard stats={stats} />;
}

async function RecentActivity() {
  const activity = await getRecentActivity(7); // Fast query
  return <ActivityList activity={activity} />;
}

export default function DashboardPage() {
  return (
    <div>
      {/* Fast content renders immediately */}
      <Suspense fallback={<ActivitySkeleton />}>
        <RecentActivity />
      </Suspense>
      
      {/* Slow content streams in later */}
      <Suspense fallback={<StatsSkeleton />}>
        <Stats />
      </Suspense>
    </div>
  );
}
```

### Optimistic Updates

```typescript
// src/components/questions/bookmark-button.tsx
'use client';

import { useOptimistic } from 'react';
import { toggleBookmark } from '@/server/actions/bookmarks';

export function BookmarkButton({ 
  questionId,
  initialBookmarked 
}: { 
  questionId: string;
  initialBookmarked: boolean;
}) {
  const [optimisticBookmarked, setOptimisticBookmarked] = useOptimistic(
    initialBookmarked,
    (state, newState: boolean) => newState
  );
  
  const handleToggle = async () => {
    setOptimisticBookmarked(!optimisticBookmarked);
    
    try {
      const result = await toggleBookmark(questionId);
      if (!result.success) {
        // Revert on error
        setOptimisticBookmarked(optimisticBookmarked);
      }
    } catch (error) {
      setOptimisticBookmarked(optimisticBookmarked);
    }
  };
  
  return (
    <button onClick={handleToggle}>
      {optimisticBookmarked ? '★' : '☆'}
    </button>
  );
}
```

### Incremental Static Regeneration

```typescript
// src/app/(app)/questions/[slug]/page.tsx

export const revalidate = 3600; // Revalidate every hour

export async function generateStaticParams() {
  const questions = await getQuestions();
  
  // Pre-render first 100 most popular questions
  const popular = questions
    .sort((a, b) => (b.metadata.popularity ?? 0) - (a.metadata.popularity ?? 0))
    .slice(0, 100);
  
  return popular.map(q => ({
    slug: q.slug,
  }));
}

export default async function QuestionPage({ params }: { params: { slug: string } }) {
  const question = await getQuestionBySlug(params.slug);
  // ... render question
}
```

---

## Type Safety & Validation

### End-to-End Type Safety

**Form Validation with Zod + React Hook Form**
```typescript
// src/components/questions/add-question-form.tsx
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { QuestionSchema } from '@/lib/validations/question';
import type { Question } from '@/lib/validations/question';

export function AddQuestionForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<Question>({
    resolver: zodResolver(QuestionSchema),
  });
  
  const onSubmit = async (data: Question) => {
    // Data is fully validated and typed
    const result = await createQuestion(data);
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('title')} />
      {errors.title && <span>{errors.title.message}</span>}
      
      <select {...register('category')}>
        {CATEGORIES.map(c => (
          <option key={c} value={c}>{c}</option>
        ))}
      </select>
      
      <button type="submit">Create Question</button>
    </form>
  );
}
```

**Type-Safe Server Actions**
```typescript
// src/server/actions/questions.ts
'use server';

import { revalidatePath } from 'next/cache';
import { QuestionSchema } from '@/lib/validations/question';
import { db } from '@/server/db';
import { questions } from '@/server/db/schema';

export async function createQuestion(data: unknown) {
  try {
    // Validate with Zod
    const validated = QuestionSchema.parse(data);
    
    // Insert into database
    await db.insert(questions).values({
      ...validated,
      tags: JSON.stringify(validated.tags),
      relatedQuestions: JSON.stringify(validated.relatedQuestions),
      resources: JSON.stringify(validated.resources),
      createdAt: new Date(),
      updatedAt: new Date(),
    });
    
    revalidatePath('/questions');
    
    return { success: true };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { 
        success: false, 
        errors: error.flatten().fieldErrors 
      };
    }
    
    return { 
      success: false, 
      error: 'Failed to create question' 
    };
  }
}
```

### Database Query Type Safety with Drizzle

```typescript
// src/server/queries/progress.ts
import { db } from '@/server/db';
import { progress, questions } from '@/server/db/schema';
import { eq, desc } from 'drizzle-orm';

// Fully typed query
export async function getProgressWithQuestions(userId: string) {
  const result = await db
    .select({
      progress: progress,
      question: questions,
    })
    .from(progress)
    .leftJoin(questions, eq(progress.questionId, questions.id))
    .where(eq(progress.userId, userId))
    .orderBy(desc(progress.updatedAt));
  
  // Type-safe result
  return result.map(row => ({
    ...row.progress,
    question: row.question,
  }));
}
```

---

## Testing Strategy

### Unit Tests (Vitest)

```typescript
// tests/unit/utils/spaced-repetition.test.ts
import { describe, it, expect } from 'vitest';
import { calculateNextReviewDate, isDueForReview } from '@/lib/utils/spaced-repetition';

describe('Spaced Repetition', () => {
  describe('calculateNextReviewDate', () => {
    it('should return 1 day for first review with neutral confidence', () => {
      const nextDate = calculateNextReviewDate(3, 0);
      const expected = new Date();
      expected.setDate(expected.getDate() + 1);
      
      expect(nextDate.getDate()).toBe(expected.getDate());
    });
    
    it('should extend interval for high confidence', () => {
      const nextDate = calculateNextReviewDate(5, 0);
      const expected = new Date();
      expected.setDate(expected.getDate() + 2); // 1 day * 2.0 multiplier
      
      expect(nextDate.getDate()).toBe(expected.getDate());
    });
    
    it('should shorten interval for low confidence', () => {
      const nextDate = calculateNextReviewDate(1, 0);
      const now = new Date();
      const diffDays = Math.round((nextDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
      
      expect(diffDays).toBeLessThan(1);
    });
  });
  
  describe('isDueForReview', () => {
    it('should return true if no review date', () => {
      expect(isDueForReview(null)).toBe(true);
    });
    
    it('should return true if review date is in the past', () => {
      const pastDate = new Date();
      pastDate.setDate(pastDate.getDate() - 1);
      
      expect(isDueForReview(pastDate)).toBe(true);
    });
    
    it('should return false if review date is in the future', () => {
      const futureDate = new Date();
      futureDate.setDate(futureDate.getDate() + 1);
      
      expect(isDueForReview(futureDate)).toBe(false);
    });
  });
});
```

### Component Tests

```typescript
// tests/unit/components/bookmark-button.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { BookmarkButton } from '@/components/questions/bookmark-button';
import * as actions from '@/server/actions/bookmarks';

// Mock server action
vi.mock('@/server/actions/bookmarks');

describe('BookmarkButton', () => {
  it('should render unbookmarked state initially', () => {
    render(<BookmarkButton questionId="test-id" initialBookmarked={false} />);
    
    expect(screen.getByRole('button')).toHaveTextContent('☆');
  });
  
  it('should toggle bookmark on click', async () => {
    vi.mocked(actions.toggleBookmark).mockResolvedValue({
      success: true,
      bookmarked: true,
    });
    
    render(<BookmarkButton questionId="test-id" initialBookmarked={false} />);
    
    const button = screen.getByRole('button');
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(button).toHaveTextContent('★');
    });
    
    expect(actions.toggleBookmark).toHaveBeenCalledWith('test-id');
  });
});
```

### Integration Tests

```typescript
// tests/integration/questions/question-flow.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { db } from '@/server/db';
import { questions, progress } from '@/server/db/schema';
import { getQuestionBySlug } from '@/server/queries/questions';
import { updateProgress } from '@/server/actions/progress';

describe('Question Progress Flow', () => {
  beforeEach(async () => {
    // Clean up database
    await db.delete(progress);
    await db.delete(questions);
    
    // Insert test question
    await db.insert(questions).values({
      id: 'test-1',
      slug: 'test-question',
      category: 'hooks',
      difficulty: 'beginner',
      title: 'Test Question',
      question: 'What is useState?',
      answer: 'useState is a hook...',
      tags: JSON.stringify(['react', 'hooks']),
      createdAt: new Date(),
      updatedAt: new Date(),
    });
  });
  
  it('should create and update progress for a question', async () => {
    const question = await getQuestionBySlug('test-question');
    expect(question).toBeTruthy();
    
    // Create progress
    const result1 = await updateProgress({
      questionId: question!.id,
      status: 'learning',
      confidenceLevel: 3,
    });
    
    expect(result1.success).toBe(true);
    
    // Update progress
    const result2 = await updateProgress({
      questionId: question!.id,
      status: 'confident',
      confidenceLevel: 4,
    });
    
    expect(result2.success).toBe(true);
    
    // Verify in database
    const progressRecord = await db
      .select()
      .from(progress)
      .where(eq(progress.questionId, question!.id))
      .limit(1);
    
    expect(progressRecord[0].status).toBe('confident');
    expect(progressRecord[0].confidenceLevel).toBe(4);
    expect(progressRecord[0].reviewCount).toBe(2);
  });
});
```

### E2E Tests (Playwright)

```typescript
// tests/e2e/questions.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Question Browsing', () => {
  test('should display list of questions', async ({ page }) => {
    await page.goto('/questions');
    
    await expect(page.getByRole('heading', { level: 1 })).toContainText('React Interview Questions');
    
    // Should display question cards
    const cards = page.locator('[data-testid="question-card"]');
    await expect(cards).toHaveCount(20); // Default page size
  });
  
  test('should filter questions by category', async ({ page }) => {
    await page.goto('/questions');
    
    // Select hooks category
    await page.getByRole('combobox', { name: 'Category' }).selectOption('hooks');
    
    // URL should update
    await expect(page).toHaveURL(/category=hooks/);
    
    // Cards should show hooks category
    const cards = page.locator('[data-testid="question-card"]');
    const firstCard = cards.first();
    await expect(firstCard).toContainText('hooks');
  });
  
  test('should navigate to question detail', async ({ page }) => {
    await page.goto('/questions');
    
    const firstCard = page.locator('[data-testid="question-card"]').first();
    await firstCard.click();
    
    // Should navigate to detail page
    await expect(page).toHaveURL(/\/questions\/[a-z0-9-]+/);
    
    // Should show question content
    await expect(page.getByRole('heading', { level: 1 })).toBeVisible();
    await expect(page.getByRole('button', { name: /show answer/i })).toBeVisible();
  });
});

test.describe('Study Mode', () => {
  test('should complete flashcard session', async ({ page }) => {
    await page.goto('/study/flashcards');
    
    // Start session with 5 questions
    await page.getByRole('button', { name: /start session/i }).click();
    
    // Flip first card
    await page.getByRole('button', { name: /flip/i }).click();
    
    // Should show answer
    await expect(page.getByTestId('flashcard-answer')).toBeVisible();
    
    // Navigate to next card
    await page.getByRole('button', { name: /next/i }).click();
    
    // Progress should update
    await expect(page.getByText('2 / 5')).toBeVisible();
  });
});
```

---

## Development Workflow

### Scripts (package.json)

```json
{
  "scripts": {
    "dev": "next dev --turbo",
    "build": "pnpm validate:questions && next build",
    "start": "next start",
    "lint": "biome check .",
    "lint:fix": "biome check --apply .",
    "format": "biome format --write .",
    "type-check": "tsc --noEmit",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:e2e": "playwright test",
    "test:coverage": "vitest --coverage",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "tsx scripts/db-migrate.ts",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio",
    "validate:questions": "tsx scripts/validate-questions.ts",
    "add:question": "tsx scripts/add-question.ts",
    "build:search": "tsx scripts/build-search-index.ts",
    "analyze": "ANALYZE=true pnpm build"
  }
}
```

### Question Validation Script

```typescript
// scripts/validate-questions.ts
import { allQuestions } from '../src/content';
import { QuestionSchema } from '../src/lib/validations/question';
import { z } from 'zod';

async function validateQuestions() {
  console.log(`Validating ${allQuestions.length} questions...
`);
  
  const errors: string[] = [];
  const seenIds = new Set<string>();
  const seenSlugs = new Set<string>();
  
  for (const question of allQuestions) {
    try {
      // Validate schema
      QuestionSchema.parse(question);
      
      // Check for duplicate IDs
      if (seenIds.has(question.id)) {
        errors.push(`Duplicate ID: ${question.id}`);
      }
      seenIds.add(question.id);
      
      // Check for duplicate slugs
      if (seenSlugs.has(question.slug)) {
        errors.push(`Duplicate slug: ${question.slug}`);
      }
      seenSlugs.add(question.slug);
      
      // Validate related questions exist
      for (const relatedId of question.relatedQuestions) {
        if (!allQuestions.some(q => q.id === relatedId)) {
          errors.push(`Question ${question.id} references non-existent question: ${relatedId}`);
        }
      }
      
      // Validate slug format
      if (!/^[a-z0-9-]+$/.test(question.slug)) {
        errors.push(`Invalid slug format: ${question.slug}`);
      }
      
      // Check minimum tag count
      if (question.tags.length === 0) {
        errors.push(`Question ${question.id} has no tags`);
      }
      
    } catch (error) {
      if (error instanceof z.ZodError) {
        errors.push(`Question ${question.id} validation failed: ${error.message}`);
      }
    }
  }
  
  if (errors.length > 0) {
    console.error('❌ Validation failed:
');
    errors.forEach(err => console.error(`  - ${err}`));
    process.exit(1);
  }
  
  console.log('✅ All questions validated successfully!');
  console.log(`
Statistics:`);
  console.log(`  Total questions: ${allQuestions.length}`);
  
  const byCategory = allQuestions.reduce((acc, q) => {
    acc[q.category] = (acc[q.category] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  
  console.log(`  By category:`);
  Object.entries(byCategory).forEach(([cat, count]) => {
    console.log(`    ${cat}: ${count}`);
  });
}

validateQuestions();
```

### CLI Tool for Adding Questions

```typescript
// scripts/add-question.ts
import * as p from '@clack/prompts';
import { writeFile } from 'fs/promises';
import { CATEGORIES, DIFFICULTIES } from '../src/lib/validations/question';

async function addQuestion() {
  console.clear();
  
  p.intro('Add New Question');
  
  const answers = await p.group({
    category: () => p.select({
      message: 'Select category',
      options: CATEGORIES.map(c => ({ value: c, label: c })),
    }),
    
    difficulty: () => p.select({
      message: 'Select difficulty',
      options: DIFFICULTIES.map(d => ({ value: d, label: d })),
    }),
    
    title: () => p.text({
      message: 'Question title',
      validate: (value) => {
        if (value.length < 5) return 'Title must be at least 5 characters';
        if (value.length > 200) return 'Title must be less than 200 characters';
      },
    }),
    
    slug: () => p.text({
      message: 'URL slug (lowercase, hyphens only)',
      validate: (value) => {
        if (!/^[a-z0-9-]+$/.test(value)) {
          return 'Slug must contain only lowercase letters, numbers, and hyphens';
        }
      },
    }),
    
    tags: () => p.text({
      message: 'Tags (comma-separated)',
    }),
  });
  
  if (p.isCancel(answers)) {
    p.cancel('Operation cancelled');
    process.exit(0);
  }
  
  const id = `${answers.category}-${Date.now()}`;
  const tags = answers.tags.split(',').map(t => t.trim());
  
  const question = {
    id,
    slug: answers.slug,
    category: answers.category,
    difficulty: answers.difficulty,
    title: answers.title,
    question: '// TODO: Add question content',
    answer: '// TODO: Add answer content',
    tags,
    relatedQuestions: [],
    resources: [],
    metadata: {
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    },
  };
  
  p.outro(`Question created! Edit the file to add content:
src/content/questions/${answers.category}.ts`);
  
  console.log(JSON.stringify(question, null, 2));
}

addQuestion();
```

### Pre-commit Hooks (Husky + lint-staged)

```json
// package.json
{
  "lint-staged": {
    "*.{ts,tsx}": [
      "biome check --apply",
      "vitest related --run"
    ],
    "src/content/**/*.ts": [
      "pnpm validate:questions"
    ]
  }
}
```

---

## Build & Deployment

### Environment Variables

```bash
# .env.example

# Database
DATABASE_URL="file:./data/app.db"

# Optional: Analytics
NEXT_PUBLIC_ANALYTICS_ID=""

# Optional: Error tracking
SENTRY_DSN=""

# Node environment
NODE_ENV="development"
```

### Build Optimization

```typescript
// next.config.ts
const config: NextConfig = {
  output: 'standalone', // For Docker deployment
  
  // Bundle analyzer (conditional)
  webpack: (config, { isServer }) => {
    if (process.env.ANALYZE === 'true') {
      const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
      config.plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: 'static',
          reportFilename: isServer
            ? '../analyze/server.html'
            : './analyze/client.html',
        })
      );
    }
    return config;
  },
};
```

### Docker Setup

```dockerfile
# Dockerfile
FROM node:20-alpine AS base

# Dependencies
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json pnpm-lock.yaml ./
RUN corepack enable pnpm && pnpm install --frozen-lockfile

# Builder
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

RUN pnpm build

# Runner
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000

CMD ["node", "server.js"]
```

### CI/CD Pipeline

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v2
        with:
          version: 9
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      
      - name: Validate questions
        run: pnpm validate:questions
      
      - name: Lint
        run: pnpm lint
      
      - name: Type check
        run: pnpm type-check
      
      - name: Run tests
        run: pnpm test:coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        
  e2e:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v2
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      
      - name: Install Playwright
        run: pnpm playwright install --with-deps
      
      - name: Run E2E tests
        run: pnpm test:e2e
      
      - uses: actions/upload-artifact@v3
        if: failure()
        with:
          name: playwright-report
          path: playwright-report/
```

---

## Additional Best Practices

### Error Handling

```typescript
// src/app/error.tsx
'use client';

import { useEffect } from 'react';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // Log to error tracking service
    console.error(error);
  }, [error]);
  
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={reset}>Try again</button>
    </div>
  );
}
```

### Loading States

```typescript
// src/app/(app)/questions/loading.tsx
export default function Loading() {
  return (
    <div>
      <div className="animate-pulse">
        {/* Skeleton UI */}
      </div>
    </div>
  );
}
```

### Metadata Generation

```typescript
// src/app/(app)/questions/[slug]/page.tsx
import type { Metadata } from 'next';

export async function generateMetadata({ 
  params 
}: { 
  params: { slug: string } 
}): Promise<Metadata> {
  const question = await getQuestionBySlug(params.slug);
  
  if (!question) {
    return {
      title: 'Question Not Found',
    };
  }
  
  return {
    title: `${question.title} | React Interview Questions`,
    description: question.question.slice(0, 160),
    openGraph: {
      title: question.title,
      description: question.question.slice(0, 160),
      type: 'article',
      tags: question.tags,
    },
  };
}
```

### Accessibility

```typescript
// Always include proper ARIA labels
<button
  aria-label="Bookmark this question"
  aria-pressed={isBookmarked}
  onClick={handleToggle}
>
  {isBookmarked ? '★' : '☆'}
</button>

// Use semantic HTML
<nav aria-label="Pagination">
  <ul>
    <li>
      <a href="?page=1" aria-label="Go to page 1">1</a>
    </li>
  </ul>
</nav>

// Keyboard navigation
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'ArrowRight') {
      nextQuestion();
    } else if (e.key === 'ArrowLeft') {
      previousQuestion();
    }
  };
  
  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, []);
```

---

This specification provides a comprehensive, production-ready architecture for building a React interview questions app with Next.js 16, modern best practices, full type safety, and excellent developer experience. The architecture is scalable, performant, and maintainable.
